Here are some example LISP programs and what your interpreter should
do with them:
[interpreter outputs are preceded by `>']:
[Note also that I have not included the lines with the single "$"
that are supposed to separate the Lisp expressions from each other, nor
the final line containing "$$". Please add those.]

[The dot notation version for each example is also provided; this
should help in case you were not able to implement the list-notation
input.  But the dot notation versions were generated by hand, so use
with caution!]

   (CAR (QUOTE (A . B)))
 > A

   (CONS 4 (QUOTE (A . B)))
 > (4 . (A . B))
dot notation:
   (CONS . (4 . ((QUOTE . ((A . B) . NIL)) . NIL)))


   (CONS 4 (A . B))
 > error (trying to evaluate (A . B) )
dot notation:
   (CONS . (4 . ((A . B) . NIL)))


   (DEFUN SILLY (A B) (PLUS A B))
 > SILLY
dot notation:
   (DEFUN . (SILLY . ((A . (B . NIL)) . ((PLUS . (A . (B . NIL))) . NIL))))

   (SILLY 5 6)
 > 11
dot notation:
   (SILLY . (5 . (6 . NIL)))

   (SILLY (CAR (QUOTE (5 . 6))) (CDR (QUOTE (5 . 6))) )
 > 11
dot notation:
  (SILLY . ( (CAR . ((QUOTE . ((5 . 6) . NIL)) . NIL)) .
               ( (CDR . ((QUOTE . ((5 . 6) . NIL)) . NIL)) . NIL)))

  (DEFUN MINUS2 (A B) (MINUS A B))
 > MINUS2

  (DEFUN . (MINUS2 . ((A . (B . NIL)) . ((MINUS . (A . (B . NIL))) . NIL))))

   (DEFUN NOTSOSILLY (A B)
            (COND
               ((EQ A 0) (PLUS B 1))
               ((EQ B 0) (NOTSOSILLY (MINUS2 A 1) 1))
               (T (NOTSOSILLY (MINUS2 A 1) (NOTSOSILLY A (MINUS2 B 1))))
             ))
 > NOTSOSILLY

  (DEFUN . (NOTSOSILLY . ((A . (B . NIL)) . ((COND . ( ( (EQ . (A . (0 . NIL))) . ( (PLUS . (B . (1 . NIL))) . NIL)) . ( ( (EQ . (B . (0 . NIL))) . ( (NOTSOSILLY . ((MINUS2 .(A . (1 . NIL))) . (1 . NIL))) . NIL)) . ( (T . ((NOTSOSILLY . ( (MINUS2 . (A . (1 . NIL))) .
                 ( (NOTSOSILLY . (A . ((MINUS2 . (B . (1 . NIL))) . NIL))) . NIL))) . NIL)) . NIL)))) . NIL))))

   (NOTSOSILLY 0 0)
 > 1

(NOTSOSILLY . (0 . (0 . NIL)))

   (NOTSOSILLY 1 1)
  > 3

(NOTSOSILLY . (1 . (1 . NIL)))


;; only one of the above had an error in it.

;; It may be useful to have a few more inputs with errors but these should
;; be errors in the "semantics", not in the syntax (of s-expressions).
;; Here are a few like that:

  (PLUS 2 NIL) ; wrong argument type

  (SILY 5 6)  ; spelling mistake in function name

  (SILLY 2 3 4) ; too many arguments

  (SILLY 2)   ; too few

;; a few interesting functions (in design notation):

; this is a really strange function! guess what it does ...
F[x] =
  [ >[x, 100] --> -[x,10];
  | T --> F[F[+[x,11]]]; ]

; and this is an important one from computation theory:
A[m,n] = ; m, n are assumed to be greater than or equal to 0
  [ =[m,0] --> +[n,1];
  | >[m,0] --> [ =[n,0] --> A[-[m,1], 1];
               | T --> A[-[m,1], A[m, -[n,1]]]; ]

;; don't try running this function for large values of n and, especially, m! you will blow the stack!
;; this is the "Ackermann function" and, as I said, important in computation theory.